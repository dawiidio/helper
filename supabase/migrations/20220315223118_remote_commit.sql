-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.


CREATE TABLE IF NOT EXISTS public.profile
(
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    surname character varying COLLATE pg_catalog."default",
    confirmed boolean NOT NULL DEFAULT false,
    is_organisation boolean NOT NULL DEFAULT false,
    id uuid NOT NULL,
    public_id uuid NOT NULL DEFAULT uuid_generate_v4(),
    phone text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default",
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profile_public_id_key UNIQUE (public_id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profile
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.profile
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profile TO anon;

GRANT ALL ON TABLE public.profile TO authenticated;

GRANT ALL ON TABLE public.profile TO postgres;

GRANT ALL ON TABLE public.profile TO service_role;

GRANT ALL ON TABLE public.profile TO supabase_admin;
CREATE POLICY "Enable access to all users"
    ON public.profile
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Enable delete for users based on user_id"
    ON public.profile
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Enable insert for authenticated users only"
    ON public.profile
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "Enable update for users based on email"
    ON public.profile
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id))
    WITH CHECK ((auth.uid() = id));

CREATE TABLE IF NOT EXISTS public.organization_unit
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    phone character varying COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    creator_id uuid NOT NULL,
    status character varying COLLATE pg_catalog."default" NOT NULL,
    city text COLLATE pg_catalog."default",
    "addressLine1" text COLLATE pg_catalog."default",
    "addressLine2" text COLLATE pg_catalog."default",
    "postalCode" character varying COLLATE pg_catalog."default",
    organization_name character varying COLLATE pg_catalog."default",
    CONSTRAINT organization_unit_pkey PRIMARY KEY (id),
    CONSTRAINT organization_unit_creator_id_fkey FOREIGN KEY (creator_id)
        REFERENCES public.profile (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.organization_unit
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.organization_unit
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.organization_unit TO anon;

GRANT ALL ON TABLE public.organization_unit TO authenticated;

GRANT ALL ON TABLE public.organization_unit TO postgres;

GRANT ALL ON TABLE public.organization_unit TO service_role;

GRANT ALL ON TABLE public.organization_unit TO supabase_admin;
CREATE POLICY "Enable access to all users"
    ON public.organization_unit
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Enable delete for users based on user_id"
    ON public.organization_unit
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = creator_id));
CREATE POLICY "Enable insert for authenticated users only"
    ON public.organization_unit
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "Enable update for users based on email"
    ON public.organization_unit
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = creator_id))
    WITH CHECK ((auth.uid() = creator_id));

CREATE TABLE IF NOT EXISTS public.need
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    name character varying COLLATE pg_catalog."default",
    unit character varying COLLATE pg_catalog."default",
    status character varying COLLATE pg_catalog."default",
    creator_id uuid NOT NULL,
    quantity bigint,
    organization_unit_id bigint NOT NULL,
    description text COLLATE pg_catalog."default",
    start_date timestamp with time zone,
    end_date timestamp with time zone,
    priority character varying COLLATE pg_catalog."default",
    supplied bigint DEFAULT '0'::bigint,
    type character varying COLLATE pg_catalog."default" NOT NULL DEFAULT 'other'::character varying,
    organizer_phone character varying COLLATE pg_catalog."default",
    organizer_email character varying COLLATE pg_catalog."default",
    organizer_name character varying COLLATE pg_catalog."default",
    CONSTRAINT need_pkey PRIMARY KEY (id),
    CONSTRAINT need_creator_id_fkey FOREIGN KEY (creator_id)
        REFERENCES public.profile (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT need_organization_unit_id_fkey FOREIGN KEY (organization_unit_id)
        REFERENCES public.organization_unit (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.need
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.need
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.need TO anon;

GRANT ALL ON TABLE public.need TO authenticated;

GRANT ALL ON TABLE public.need TO postgres;

GRANT ALL ON TABLE public.need TO service_role;

GRANT ALL ON TABLE public.need TO supabase_admin;
CREATE POLICY "Enable access to all users"
    ON public.need
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Enable delete for users based on user_id"
    ON public.need
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = creator_id));
CREATE POLICY "Enable insert for authenticated users only"
    ON public.need
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.role() = 'authenticated'::text));
CREATE POLICY "Enable update for users based on email"
    ON public.need
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = creator_id))
    WITH CHECK ((auth.uid() = creator_id));


